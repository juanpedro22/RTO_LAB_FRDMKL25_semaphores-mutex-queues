/* MODULE os_tasks */

#include "Cpu.h"
#include "Events.h"
#include "os_tasks.h"

#ifdef __cplusplus
extern "C" {
#endif 

/* User includes (#include below this line is not maintained by Processor Expert) */
#include "ledrgb_hal.h"

/* ###################################################################
** SELETOR DE IMPLEMENTA√á√ÉO (Item 2.1, Etapa 2 e 3)
** ###################################################################
**
** Descomente a linha abaixo para compilar a Parte B (Mutex).
** Deixe-a comentada para compilar a Parte A (Sem√°foro).
**
*/
#define USE_MUTEX_IMPLEMENTATION
/* ################################################################### */


/* ** Vari√°veis Globais de Sincroniza√ß√£o
** O pr√©-processador ir√° escolher qual vari√°vel criar.
*/
#if defined(USE_MUTEX_IMPLEMENTATION)
  /* Parte B: Mutex */
  mutex_t g_led_mutex; // <--- CORRETO
#else
  /* Parte A: Sem√°foro (Default) */
  semaphore_t g_led_semaphore; // <--- CORRETO
#endif


/*
** ===================================================================
** Event    :  Task1_task (module os_tasks)
** ===================================================================
*/
  void Task1_task(os_task_param_t task_init_data)
  {
    /* Defini√ß√£o dos estados da FSM 1 (com sincroniza√ß√£o) */
    typedef enum {
      STATE_WAIT_FOR_RESOURCE,
      STATE_CRITICAL_SECTION_ON,
      STATE_RELEASE_AND_WAIT_OFF
    } fsm1_state_t;

    /* Inicializa√ß√£o da FSM 1 */
    fsm1_state_t currentState = STATE_WAIT_FOR_RESOURCE;

    /* Vari√°vel para checar o status da cria√ß√£o */
    osa_status_t status;

    /* Inicializa o hardware do LED RGB (apenas uma vez) */
    ledrgb_init();

    /* ** Cria o objeto de Sincroniza√ß√£o (apenas uma vez)
    ** A Task1 ser√° respons√°vel por criar o objeto.
    */
  #if defined(USE_MUTEX_IMPLEMENTATION)
    /* Parte B: Cria o Mutex */
    status = OSA_MutexCreate(&g_led_mutex);
  #else
    /* Parte A: Cria o Sem√°foro Bin√°rio (valor inicial 1 = "dispon√≠vel") */
    status = OSA_SemaCreate(&g_led_semaphore, 1);
  #endif

    /* ** ==============================================================
    ** TESTE DE DIAGN√ìSTICO
    ** ==============================================================
    */
    if (status != kStatus_OSA_Success)
    {
        /* ** SE O LED VERMELHO ACENDER E FICAR ACESO,
        ** ** SIGNIFICA QUE A CRIA√á√ÉO FALHOU (FALTA DE HEAP)!
        */
        ledrgb_setRedLed();   // Acende o LED vermelho...
        ledrgb_clearGreenLed();
        ledrgb_clearBlueLed();
        while(1) {
            /* Trava a tarefa aqui para sempre */
            /* O problema √© FALTA DE HEAP no PEX. */
        }
    }
    /* Se o c√≥digo chegou aqui, o objeto foi criado com SUCESSO. */

  #ifdef PEX_USE_RTOS
    while (1) {
  #endif

      /* Implementa√ß√£o da M√°quina de Estados Finitos (FSM) 1 */
      switch (currentState) {

      /* O RESTO DO C√ìDIGO PERMANECE ID√äNTICO */

        case STATE_WAIT_FOR_RESOURCE:
          /* 1. Tentar "pegar" o recurso.
          ** A tarefa ficar√° BLOQUEADA aqui at√© conseguir.
          */
  #if defined(USE_MUTEX_IMPLEMENTATION)
          OSA_MutexLock(&g_led_mutex, OSA_WAIT_FOREVER);
  #else
          OSA_SemaWait(&g_led_semaphore, OSA_WAIT_FOREVER);
  #endif
          /* Transi√ß√£o: Recurso adquirido! */
          currentState = STATE_CRITICAL_SECTION_ON;
          break;

        case STATE_CRITICAL_SECTION_ON:
          /* ** =================== IN√?CIO DA SE√á√ÉO CR√?TICA =================== */

          /* 2. Definir a cor (garantindo que as outras est√£o apagadas) */
          ledrgb_setRedLed();
          ledrgb_clearGreenLed();

          /* 3. Manter o LED aceso (e manter a trava) */
          OSA_TimeDelay(500); /* 500 ms */

          /* Transi√ß√£o: Hora de desligar e liberar */
          currentState = STATE_RELEASE_AND_WAIT_OFF;
          break;

        case STATE_RELEASE_AND_WAIT_OFF:
          /* 4. Apagar o LED (ainda dentro da se√ß√£o cr√≠tica) */
          ledrgb_clearRedLed();

          /* 5. "Devolver" o recurso para a outra tarefa. */
  #if defined(USE_MUTEX_IMPLEMENTATION)
          OSA_MutexUnlock(&g_led_mutex);
  #else
          OSA_SemaPost(&g_led_semaphore);
  #endif
          /* ** =================== FIM DA SE√á√ÉO CR√?TICA ==================== */

          /* 6. Esperar o per√≠odo "OFF" (fora da se√ß√£o cr√≠tica) */
          OSA_TimeDelay(500); /* 500 ms */

          /* Transi√ß√£o: Voltar ao in√≠cio para tentar de novo */
          currentState = STATE_WAIT_FOR_RESOURCE;
          break;

        default:
          currentState = STATE_WAIT_FOR_RESOURCE;
          break;
      }

  #ifdef PEX_USE_RTOS
    }
  #endif
  }

/*
** ===================================================================
** Event    :  Task2_task (module os_tasks)
** ===================================================================
*/
void Task2_task(os_task_param_t task_init_data)
{
  /* Defini√ß√£o dos estados da FSM 2 (com sincroniza√ß√£o) */
  typedef enum {
    STATE_WAIT_FOR_RESOURCE,
    STATE_CRITICAL_SECTION_ON,
    STATE_RELEASE_AND_WAIT_OFF
  } fsm2_state_t;

  /* Inicializa√ß√£o da FSM 2 */
  fsm2_state_t currentState = STATE_WAIT_FOR_RESOURCE;

#ifdef PEX_USE_RTOS
  while (1) {
#endif

    /* Implementa√ß√£o da M√°quina de Estados Finitos (FSM) 2 */
    switch (currentState) {

      case STATE_WAIT_FOR_RESOURCE:
        /* 1. Tentar "pegar" o recurso. */
#if defined(USE_MUTEX_IMPLEMENTATION)
        OSA_MutexLock(&g_led_mutex, OSA_WAIT_FOREVER);
#else
        OSA_SemaWait(&g_led_semaphore, OSA_WAIT_FOREVER);
#endif
        /* Transi√ß√£o: Recurso adquirido! */
        currentState = STATE_CRITICAL_SECTION_ON;
        break;

      case STATE_CRITICAL_SECTION_ON:
        /* ** =================== IN√?CIO DA SE√á√ÉO CR√?TICA ===================
        */

        /* 2. Definir a cor */
        ledrgb_setGreenLed();
        ledrgb_clearRedLed();
        // ledrgb_clearBlueLed(); // Boa pr√°tica

        /* 3. Manter o LED aceso (e manter a trava) */
        OSA_TimeDelay(300); /* 300 ms */

        /* Transi√ß√£o: Hora de desligar e liberar */
        currentState = STATE_RELEASE_AND_WAIT_OFF;
        break;

      case STATE_RELEASE_AND_WAIT_OFF:
        /* 4. Apagar o LED */
        ledrgb_clearGreenLed();

        /* 5. "Devolver" o recurso */
#if defined(USE_MUTEX_IMPLEMENTATION)
        OSA_MutexUnlock(&g_led_mutex);
#else
        OSA_SemaPost(&g_led_semaphore);
#endif
        /* ** =================== FIM DA SE√á√ÉO CR√?TICA ====================
        */

        /* 6. Esperar o per√≠odo "OFF" */
        OSA_TimeDelay(300); /* 300 ms */

        /* Transi√ß√£o: Voltar ao in√≠cio para tentar de novo */
        currentState = STATE_WAIT_FOR_RESOURCE;
        break;

      default:
        currentState = STATE_WAIT_FOR_RESOURCE;
        break;
    }

#ifdef PEX_USE_RTOS
  }
#endif
}
/* END os_tasks */

#ifdef __cplusplus
}  /* extern "C" */
#endif
