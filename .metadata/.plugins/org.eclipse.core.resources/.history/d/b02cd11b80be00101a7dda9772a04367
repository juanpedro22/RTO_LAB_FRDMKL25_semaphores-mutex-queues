/* os_tasks.c - using OSA mutex + OSA message queue for Task communication */

#include "Cpu.h"
#include "Events.h"
#include "os_tasks.h"

#include "FreeRTOS.h"
#include "task.h"

#include "ledrgb_hal.h"
#include "fsl_debug_console.h"
#include "fsl_os_abstraction.h" /* for OSA_MsgQGet/Put and macros */

#ifndef pdMS_TO_TICKS
#define pdMS_TO_TICKS(ms) ((TickType_t)((((TickType_t)(ms) * (TickType_t)configTICK_RATE_HZ) + 500u) / 1000u))
#endif

/* externs from main.c */
extern mutex_t ledMutex;
extern msg_queue_t *ledQueue; /* declared with MSG_QUEUE_DECLARE in main.c */

/* small wrappers for readability */
static inline void led_mutex_lock(void)
{
    (void)OSA_MutexLock(&ledMutex, OSA_WAIT_FOREVER);
}
static inline void led_mutex_unlock(void)
{
    (void)OSA_MutexUnlock(&ledMutex);
}

/* Message codes (must match main.c) */
#define MSG_BLINK_GREEN   (1U)
#define MSG_NOOP          (0U)

/* Task1: sets RED and notifies Task2 via message queue */
void Task1_task(os_task_param_t task_init_data)
{
    typedef enum { STATE_RED_ON, STATE_RED_OFF } fsm1_state_t;
    fsm1_state_t currentState = STATE_RED_ON;

    ledrgb_init();

#ifdef PEX_USE_RTOS
    while (1) {
#endif
        switch (currentState) {
            case STATE_RED_ON:
                /* protect HAL access briefly */
                led_mutex_lock();
                ledrgb_setRedLed();
                led_mutex_unlock();

                /* remain ON for 500 ms */
                vTaskDelay(pdMS_TO_TICKS(500));

                /* notify Task2: request one green blink cycle */
                {
                    uint32_t msg = MSG_BLINK_GREEN;
                    /* OSA_MsgQPut expects a pointer to the message */
                    (void)OSA_MsgQPut(ledQueue, (void *)&msg);
                    /* ignore return here for brevity; in production check status */
                }

                currentState = STATE_RED_OFF;
                break;

            case STATE_RED_OFF:
                led_mutex_lock();
                ledrgb_clearRedLed();
                led_mutex_unlock();

                vTaskDelay(pdMS_TO_TICKS(500));
                currentState = STATE_RED_ON;
                break;

            default:
                currentState = STATE_RED_ON;
                break;
        }
#ifdef PEX_USE_RTOS
    }
#endif
}

/* Task2: waits for message and executes green blink cycle when requested */
void Task2_task(os_task_param_t task_init_data)
{
    typedef enum { STATE_WAIT_MSG, STATE_GREEN_ON, STATE_GREEN_OFF } fsm2_state_t;
    fsm2_state_t currentState = STATE_WAIT_MSG;
    uint32_t received_msg = MSG_NOOP;

    ledrgb_init();

#ifdef PEX_USE_RTOS
    while (1) {
#endif
        switch (currentState) {

            case STATE_WAIT_MSG:
                /* block indefinitely until a message arrives */
                if (OSA_MsgQGet(ledQueue, (void *)&received_msg, OSA_WAIT_FOREVER) == kStatus_OSA_Success) {
                    if (received_msg == MSG_BLINK_GREEN) {
                        currentState = STATE_GREEN_ON;
                    } else {
                        /* unknown message: ignore and loop */
                        currentState = STATE_WAIT_MSG;
                    }
                } else {
                    /* timeout/error: continue waiting */
                    currentState = STATE_WAIT_MSG;
                }
                break;

            case STATE_GREEN_ON:
                led_mutex_lock();
                ledrgb_setGreenLed();
                led_mutex_unlock();

                vTaskDelay(pdMS_TO_TICKS(300));
                currentState = STATE_GREEN_OFF;
                break;

            case STATE_GREEN_OFF:
                led_mutex_lock();
                ledrgb_clearGreenLed();
                led_mutex_unlock();

                vTaskDelay(pdMS_TO_TICKS(300));
                /* after finishing blink cycle go back to waiting for next message */
                currentState = STATE_WAIT_MSG;
                break;

            default:
                currentState = STATE_WAIT_MSG;
                break;
        }
#ifdef PEX_USE_RTOS
    }
#endif
}
