/* ###################################################################
** Filename    : os_tasks.c
** Project     : lab3
** Processor   : MKL25Z128VLK4
** Component   : Events
** Version     : Driver 01.00
** Compiler    : GNU C Compiler
** Date/Time   : 2025-10-26, 16:10, # CodeGen: 2
** Abstract    :
** This is user's event module.
** Put your event handler code here.
** Settings    :
** Contents    :
** Task1_task - void Task1_task(os_task_param_t task_init_data);
**
** ###################################################################*/
/*!
** @file os_tasks.c
** @version 01.00
** @brief
** This is user's event module.
** Put your event handler code here.
*/
/*!
** @addtogroup os_tasks_module os_tasks module documentation
** @{
*/
/* MODULE os_tasks */

#include "Cpu.h"
#include "Events.h"
#include "os_tasks.h"

#ifdef __cplusplus
extern "C" {
#endif


/* User includes (#include below this line is not maintained by Processor Expert) */

/* Incluindo a nova Hardware Abstraction Layer (HAL) para os LEDs */
#include "ledrgb_hal.h"

/* Adicione a inclusão do header do OSA se não estiver já no projeto.
   Dependendo do seu SDK/Processor Expert o nome pode variar:
   exemplos comuns: "fsl_os_abstraction.h", "osa.h", "osa_api.h" */
#include "fsl_os_abstraction.h" /* ajuste se o seu projeto usar outro nome */

/* Declaração do semáforo (visível para ambas as tasks) */
static OSA_SEMA_STRUCT ledSema;

/* --- Task1: cria o semáforo e posta para Task2 --- */
void Task1_task(os_task_param_t task_init_data)
{
  typedef enum { STATE_RED_ON, STATE_RED_OFF } fsm1_state_t;
  fsm1_state_t currentState = STATE_RED_ON;

  /* Inicializa HAL do LED */
  ledrgb_init();

  /* Cria o semáforo (contagem inicial 0) -- criar apenas uma vez */
  /* Verifique o retorno para tratamento de erro */
  if (OSA_SemaCreate(&ledSema, 0) != kStatus_OSA_Success) {
    /* Trate erro: semáforo não criado */
    for(;;) {} /* ou log de erro, blink de falha, etc. */
  }

#ifdef PEX_USE_RTOS
  while (1) {
#endif

    switch (currentState) {
      case STATE_RED_ON:
        ledrgb_setRedLed();
        OSA_TimeDelay(500); /* 500 ms */

        /* sinaliza Task2 que pode proceder */
        OSA_SemaPost(&ledSema);

        currentState = STATE_RED_OFF;
        break;

      case STATE_RED_OFF:
        ledrgb_clearRedLed();
        OSA_TimeDelay(500); /* 500 ms */
        currentState = STATE_RED_ON;
        break;

      default:
        currentState = STATE_RED_ON;
        break;
    }

#ifdef PEX_USE_RTOS
  }
#endif
}

/* --- Task2: espera semáforo antes de piscar o LED verde --- */
void Task2_task(os_task_param_t task_init_data)
{
  typedef enum { STATE_GREEN_ON, STATE_GREEN_OFF } fsm2_state_t;
  fsm2_state_t currentState = STATE_GREEN_ON;

#ifdef PEX_USE_RTOS
  while (1) {
#endif

    /* Aguarda semáforo (bloqueante). Usa OSA_WAIT_FOREVER para aguardar indefinidamente.
       Se desejar timeout use um valor em ms. */
    if (OSA_SemaWait(&ledSema, OSA_WAIT_FOREVER) == kStatus_OSA_Success) {

      switch (currentState) {
        case STATE_GREEN_ON:
          ledrgb_setGreenLed();
          OSA_TimeDelay(300); /* 300 ms */
          currentState = STATE_GREEN_OFF;
          break;

        case STATE_GREEN_OFF:
          ledrgb_clearGreenLed();
          OSA_TimeDelay(300); /* 300 ms */
          currentState = STATE_GREEN_ON;
          break;

        default:
          currentState = STATE_GREEN_ON;
          break;
      }

      /* opcional: se quiser que Task2 libere Task1 novamente:
         OSA_SemaPost(&ledSema);  // remove isto se não for necessário */

    } else {
      /* timeout ou erro no wait: trate se necessário */
    }

#ifdef PEX_USE_RTOS
  }
#endif
}


